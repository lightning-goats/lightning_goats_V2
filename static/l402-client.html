<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>L402 Camera Switch Client (WebSocket)</title> <!-- Updated Title -->
    <script src="https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.min.js"></script>
    <!-- Removed OBS Lib -->
    <style>
        body { font-family: sans-serif; max-width: 500px; margin: 20px auto; padding: 15px; line-height: 1.6; color: #333; background-color: #f8f8f8; }
        .container { display: flex; flex-direction: column; gap: 20px; }
        .card { background-color: #fff; border: 1px solid #ddd; border-radius: 8px; padding: 20px; box-shadow: 0 2px 5px rgba(0, 0, 0, 0.06); text-align: center; }
        .form-group { margin-bottom: 15px; text-align: left; }
        label { display: block; margin-bottom: 6px; font-weight: 500; font-size: 0.95em; color: #555;}
        input[type="text"] { width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 1em; box-sizing: border-box; }
        input:read-only { background-color: #eee; cursor: not-allowed;}
        button { background-color: #ffd700; color: #000; border: none; padding: 10px 15px; border-radius: 4px; cursor: pointer; font-size: 1em; font-weight: 500; transition: background-color 0.2s; margin-right: 5px; margin-top: 5px;}
        button:hover { background-color: #f0c400; }
        button:disabled { background-color: #e0e0e0; color: #999; cursor: not-allowed; }
        .resource-content { background-color: #f0f0f0; padding: 15px; border-radius: 4px; white-space: pre-wrap; font-family: monospace; margin-bottom: 15px; text-align: left;}
        .token-info { font-family: monospace; font-size: 0.9em; white-space: pre-wrap; word-break: break-all; background: #eee; padding: 10px; border-radius: 4px; text-align: left;}
        .status { margin-top: 15px; padding: 12px; border-radius: 4px; border: 1px solid transparent; font-size: 0.95em; text-align: center; }
        .status.success { background-color: #dff0d8; color: #3c763d; border-color: #d6e9c6; }
        .status.error { background-color: #f2dede; color: #a94442; border-color: #ebccd1; }
        .status.info { background-color: #d9edf7; color: #31708f; border-color: #bce8f1; }
        .invoice-container { display: flex; flex-direction: column; align-items: center; gap: 15px; margin-bottom: 20px; }
        .qr-code { text-align: center; border: 1px solid #eee; padding: 10px; background: white; min-height: 150px; display: flex; align-items: center; justify-content: center;}
        .qr-code a { display: block; cursor: pointer; }
        .qr-code img { display: block; margin: auto; max-width: 100%; height: auto;}
        .hidden { display: none; }
        .button-group { display: flex; gap: 10px; margin-top: 10px; flex-wrap: wrap; justify-content: center; }
        small { color: #666; }
        h1, h2 { text-align: center; color: #444;}
        code { background: #eee; padding: 2px 4px; border-radius: 3px; font-family: monospace;}
        /* Added WS Status Style */
        #ws-status { font-size: 0.85em; text-align: center; padding: 5px; border-radius: 4px; margin-top: 10px;}
        #ws-status.connected { background-color: #dff0d8; color: #3c763d; }
        #ws-status.disconnected { background-color: #f2dede; color: #a94442; }
        #ws-status.connecting { background-color: #d9edf7; color: #31708f; }
    </style>
</head>
<body>
    <h1>âš¡ L402 Camera Switch Client (WebSocket)</h1>

    <div class="container">

        <div id="l402-section">
            <!-- Status for loading/requests & WebSocket -->
            <div id="request-status" class="status info">Loading Camera Switch Access...</div>
            <div id="ws-status" class="status disconnected hidden">WebSocket Disconnected</div>

            <div id="invoice-card" class="card hidden">
                <h2>Payment Required (Camera Switch)</h2>
                <div class="invoice-container">
                    <div id="qr-code" class="qr-code">Generating QR...</div>
                    <div class="button-group">
                        <button id="copy-invoice-btn">Copy Invoice</button>
                    </div>
                    <div>
                        <small>Invoice amount: <span id="invoice-amount">?</span> sats</small>
                    </div>
                </div>
                <div class="form-group">
                    <label for="invoice">BOLT11 Invoice:</label>
                    <input type="text" id="invoice" readonly>
                </div>
                <div class="form-group">
                    <label for="payment-hash">Payment Hash:</label>
                    <input type="text" id="payment-hash" readonly>
                </div>
                 <!-- Removed Auto-check Checkbox -->
                <div class="button-group">
                    <!-- Manual check button kept as fallback -->
                    <button id="check-payment-btn">Check Payment Status Manually</button>
                    <button id="use-preimage-btn">Use Manual Preimage</button>
                </div>
                 <div class="form-group" style="margin-top: 15px;">
                    <label for="preimage">Payment Preimage (optional manual entry):</label>
                    <input type="text" id="preimage" placeholder="Enter 64-char hex preimage if obtained manually">
                 </div>
                <div id="payment-status" class="status info">Awaiting payment (listening via WebSocket)...</div>
            </div>

            <div id="resource-card" class="card hidden">
                <h2>Camera Switch Accessed</h2>
                <pre id="resource-content" class="resource-content"></pre>
                <h3>LSAT Token Information</h3>
                <div id="token-info" class="token-info"></div>
                <div class="button-group">
                    <button id="access-again-btn">Refresh Camera Status</button>
                    <button id="clear-token-btn">Revoke Access / Clear Token</button>
                </div>
            </div>

             <div class="card">
                 <h2>Camera Switch</h2>
                 <p>Server: <code>https://lightning-goats.com</code></p>
                 <p>Pay the invoice above (if shown) to get temporary access. Status updates via WebSocket.</p>
                 <button id="request-btn">Re-Check / Request Invoice</button>
             </div>
        </div>
        <!-- Removed Stored Tokens Tab Section -->

    </div> <!-- End Container -->

    <script>
        // --- Global State ---
        window.currentMacaroon = null;
        window.currentPaymentHash = null;
        const CAMERA_SWITCH_RESOURCE_ID = 'basic-feed';
        window.currentResourceId = CAMERA_SWITCH_RESOURCE_ID;
        window.currentToken = null;
        let ws = null; // WebSocket instance
        let wsConnected = false;
        let wsReconnectAttempts = 0;
        const MAX_WS_RECONNECT_ATTEMPTS = 5;

        // --- Helper Functions ---
        const showElement = (id) => document.getElementById(id)?.classList.remove('hidden');
        const hideElement = (id) => document.getElementById(id)?.classList.add('hidden');
        const setValue = (id, value) => { const el = document.getElementById(id); if (el) el.value = value; };
        const setContent = (id, text) => { const el = document.getElementById(id); if (el) el.textContent = text; };
        const setHtml = (id, html) => { const el = document.getElementById(id); if (el) el.innerHTML = html; };
        const enableElement = (id) => { const el = document.getElementById(id); if (el) el.disabled = false; };
        const disableElement = (id) => { const el = document.getElementById(id); if (el) el.disabled = true; };

        function setStatus(id, message, type = 'info') {
            const statusEl = document.getElementById(id); if (!statusEl) return;
            statusEl.textContent = message; statusEl.className = 'status ' + type; showElement(id);
        }
        function setWsStatus(message, statusClass) {
             const wsStatusEl = document.getElementById('ws-status');
             if (!wsStatusEl) return;
             wsStatusEl.textContent = `WebSocket: ${message}`;
             wsStatusEl.className = 'status ' + statusClass;
             showElement('ws-status');
        }

        function displayQRCode(invoiceString) { /* ... unchanged ... */ const qrCodeContainer = document.getElementById('qr-code'); if (!qrCodeContainer) return; try { if (!invoiceString) { setHtml('qr-code', '<p style="color: red;">Error: No invoice data for QR code.</p>'); return; } const typeNumber = 0; const errorCorrectionLevel = 'L'; const qr = qrcode(typeNumber, errorCorrectionLevel); const upperInvoice = invoiceString.toUpperCase(); qr.addData(upperInvoice); qr.make(); const imgTag = qr.createImgTag(5, 5, "Click to Pay Invoice"); setHtml('qr-code', `<a href="lightning:${invoiceString}" title="Click to pay with web+ln capable wallet">${imgTag}</a>`); } catch (e) { console.error("QR Code generation failed:", e); setHtml('qr-code', '<p style="color: red;">QR Code Error</p>'); } }

        // --- LSAT Token Storage ---
        const LSAT_STORAGE_KEY = 'lsat-camera-switch-token';
        function storeToken(lsatToken, expiresAt) { /* ... unchanged ... */ if (!lsatToken || !expiresAt) return; const tokenData = { token: lsatToken, expiresAt: expiresAt }; localStorage.setItem(LSAT_STORAGE_KEY, JSON.stringify(tokenData)); console.log(`Stored Camera Switch token`); }
        function getStoredToken() { /* ... unchanged ... */ const stored = localStorage.getItem(LSAT_STORAGE_KEY); if (!stored) return null; const tokenData = JSON.parse(stored); if (tokenData && tokenData.expiresAt > (Date.now() / 1000 + 5)) { return tokenData.token; } if (tokenData) { clearToken(); } return null; }
        function clearToken() { /* ... unchanged ... */ localStorage.removeItem(LSAT_STORAGE_KEY); console.log(`Cleared Camera Switch token`); }
        function clearAllTokens() { clearToken(); }

        // --- L402 Core Logic ---
        function extractChallenge(headers) { /* ... unchanged ... */ const authHeader = headers.get('WWW-Authenticate'); console.log("Received WWW-Authenticate Header:", authHeader); if (!authHeader || !authHeader.startsWith('LSAT ')) { console.error("WWW-Authenticate header missing or invalid format."); return null; } const macaroonMatch = authHeader.match(/macaroon="([^"]+)"/); const invoiceMatch = authHeader.match(/invoice="([^"]+)"/); if (!macaroonMatch || !invoiceMatch) { console.error("Could not parse macaroon or invoice from challenge header."); return null; } console.log("Parsed Challenge:", { macaroon: macaroonMatch[1].substring(0,10)+"...", invoice: invoiceMatch[1].substring(0,10)+"..."}); return { macaroon: macaroonMatch[1], invoice: invoiceMatch[1] }; }
        const SERVER_BASE_URL = "https://lightning-goats.com";
        function getBaseUrl() { return SERVER_BASE_URL; }
        function createLsatToken(macaroonB64, preimageHex) { /* ... unchanged ... */ if (!macaroonB64 || !preimageHex) return null; return `LSAT ${macaroonB64}:${preimageHex}`; }

        // --- WebSocket Logic ---
        function connectWebSocket() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                console.log("WebSocket already open.");
                setWsStatus("Connected", "connected");
                disableElement('check-payment-btn'); // Disable manual check when connected
                return;
            }
            // Construct WSS URL from base URL
            const wsUrl = getBaseUrl().replace(/^http/, 'ws') + '/ws/'; // Assumes /ws endpoint
            console.log(`Connecting WebSocket to ${wsUrl}...`);
            setWsStatus("Connecting...", "connecting");
            hideElement('payment-status'); // Hide payment status while connecting WS

            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                console.log("WebSocket connection established.");
                setWsStatus("Connected", "connected");
                wsConnected = true;
                wsReconnectAttempts = 0; // Reset reconnect attempts on success
                disableElement('check-payment-btn'); // Disable manual check
                setStatus('payment-status', 'Connected. Waiting for payment confirmation...', 'info');
            };

            ws.onmessage = (event) => {
                console.log("WebSocket message received:", event.data);
                try {
                    const message = JSON.parse(event.data);
                    if (message.type === 'l402_payment_confirmed' && message.data) {
                        const receivedHash = message.data.payment_hash;
                        const expectedHash = window.currentPaymentHash;
                        console.log(`Received confirmation for hash ${receivedHash}, expecting ${expectedHash}`);

                        if (receivedHash && expectedHash && receivedHash === expectedHash) {
                            console.log("Matching payment confirmed via WebSocket!");
                            setStatus('payment-status', 'Payment Confirmed via WebSocket! Fetching Preimage...', 'success');
                            disconnectWebSocket(); // Close WS once payment is confirmed
                            // Fetch preimage and proceed
                            fetchPreimageAndProceed(expectedHash);
                        } else {
                             console.log("Received confirmation for a different payment hash.");
                        }
                    } else if (message.type === 'info') { // Handle general info messages
                        setStatus('payment-status', `Info: ${message.data?.message || 'Received info message.'}`, 'info');
                    }
                    // Handle other message types if needed
                } catch (e) {
                    console.error("Failed to parse WebSocket message:", e);
                }
            };

            ws.onerror = (error) => {
                console.error("WebSocket error:", error);
                setWsStatus(`Error: ${error.message || 'Connection failed'}`, "error");
                wsConnected = false;
                enableElement('check-payment-btn'); // Re-enable manual check on WS error
                // Consider attempting reconnect here or in onClose
            };

            ws.onclose = (event) => {
                console.log(`WebSocket connection closed. Code: ${event.code}, Reason: ${event.reason}`);
                wsConnected = false;
                ws = null;
                setWsStatus(`Disconnected. ${event.reason || ''}`, "disconnected");
                enableElement('check-payment-btn'); // Re-enable manual check

                // Simple Reconnect Logic (optional)
                if (!event.wasClean && wsReconnectAttempts < MAX_WS_RECONNECT_ATTEMPTS) {
                     wsReconnectAttempts++;
                     const delay = Math.pow(2, wsReconnectAttempts) * 1000; // Exponential backoff
                     console.log(`Attempting WebSocket reconnect #${wsReconnectAttempts} in ${delay/1000}s...`);
                     setTimeout(connectWebSocket, delay);
                     setWsStatus(`Disconnected. Retrying (${wsReconnectAttempts}/${MAX_WS_RECONNECT_ATTEMPTS})...`, "disconnected");
                } else if (!event.wasClean) {
                     setWsStatus(`Disconnected permanently after ${wsReconnectAttempts} retries. Please check connection or refresh.`, "error");
                }
            };
        }

        function disconnectWebSocket() {
             if (ws) {
                 console.log("Disconnecting WebSocket.");
                 ws.close(1000, "Client disconnecting"); // Normal closure
                 ws = null;
                 wsConnected = false;
             }
        }

        async function fetchPreimageAndProceed(paymentHash) {
             if (!paymentHash) return;
             setStatus('payment-status', `Fetching payment details for ${paymentHash.substring(0,10)}...`, 'info');
             try {
                const response = await fetch(`${getBaseUrl()}/l402/payment/${paymentHash}`);
                if (!response.ok) { throw new Error(`Server error ${response.status} fetching payment details.`); }
                const data = await response.json();

                 if (data.status === 'paid' && data.preimage && data.preimage !== "0" * 64) {
                     setStatus('payment-status', 'Preimage received! Accessing Camera Switch...', 'success');
                     const macaroon = window.currentMacaroon;
                     const resourceId = CAMERA_SWITCH_RESOURCE_ID;
                     if (macaroon && resourceId) {
                         const token = createLsatToken(macaroon, data.preimage);
                         if (token) {
                              await fetchResourceWithToken(resourceId, token);
                         } else { throw new Error('Failed to construct LSAT token.'); }
                     } else { throw new Error('Internal client error: Missing macaroon/resource ID.'); }
                 } else {
                      throw new Error(`Payment details indicate not paid or invalid preimage received (Status: ${data.status}).`);
                 }
             } catch (error) {
                 console.error("Error fetching preimage/accessing resource:", error);
                 setStatus('payment-status', `Error: ${error.message}`, 'error');
                 // Maybe show re-request button or manual check button prominently here
                 enableElement('check-payment-btn');
             }
        }


        // --- Modified Main Request Flow ---
        async function requestCameraSwitchAccess() {
             hideElement('invoice-card');
             hideElement('resource-card');
             setStatus('request-status', 'Requesting Camera Switch Access...', 'info');
             const requestButton = document.getElementById('request-btn');
             if(requestButton) requestButton.disabled = true;
             disconnectWebSocket(); // Disconnect previous WS if re-requesting

             const resourceId = CAMERA_SWITCH_RESOURCE_ID;
             window.currentResourceId = resourceId;
             window.currentMacaroon = null; window.currentPaymentHash = null; window.currentToken = null;

             // 1. Check stored token
             const storedToken = getStoredToken();
             if (storedToken) {
                 setStatus('request-status', 'Found valid stored token. Attempting access...', 'info');
                 if(requestButton) requestButton.disabled = false;
                 await fetchResourceWithToken(resourceId, storedToken);
                 return;
             }
             setStatus('request-status', 'No valid token. Requesting Camera Switch invoice...', 'info');

             // 2. Fetch to get 402 challenge
             try {
                 const url = `${getBaseUrl()}/l402/protected/${resourceId}`;
                 const response = await fetch(url);

                 if (response.ok) { /* ... handle direct access ... */ setStatus('request-status', 'Access granted directly.', 'success'); displayResource(await response.json(), null); }
                 else if (response.status === 402) {
                      const challenge = extractChallenge(response.headers);
                      let responseData = {}; try { responseData = await response.json(); } catch(e){ console.warn("402 body parse failed");}
                      const macaroon = challenge?.macaroon; const invoice = challenge?.invoice || responseData.invoice; const paymentHash = responseData.payment_hash; const amount = responseData.amount || '?';
                      if (!macaroon || !invoice || !paymentHash) { throw new Error('Server sent invalid 402 response.'); }

                      setStatus('request-status', 'Payment required. Invoice details below.', 'info');
                      window.currentMacaroon = macaroon;
                      window.currentPaymentHash = paymentHash; // Store hash to wait for WS message

                      setValue('invoice', invoice); setValue('payment-hash', paymentHash);
                      setContent('invoice-amount', amount); setValue('preimage','');
                      displayQRCode(invoice);

                      hideElement('resource-card'); showElement('invoice-card');
                      setStatus('payment-status', 'Please pay the invoice. Listening for confirmation via WebSocket...', 'info');
                      connectWebSocket(); // <<< Connect WebSocket AFTER showing invoice
                 } else { /* ... handle other errors (409, etc) ... */ const errorText = await response.text(); if (response.status === 409 || response.status === 403) { setStatus('request-status', `Access Denied: ${errorText || response.statusText}`, 'error'); } else { throw new Error(`Server error ${response.status}: ${errorText}`); } }
             } catch (error) { console.error("Error requesting Camera Switch:", error); setStatus('request-status', `Error: ${error.message}`, 'error'); }
             finally { if(requestButton) requestButton.disabled = false; }
        }

        async function fetchResourceWithToken(resourceId, lsatToken) {
             // ... (Implementation remains largely the same, now called after WS confirms + preimage fetch) ...
              if (resourceId !== CAMERA_SWITCH_RESOURCE_ID || !lsatToken) { alert('Invalid parameters.'); return; } setStatus('request-status', `Accessing Camera Switch with token...`, 'info'); hideElement('invoice-card'); try { const url = `${getBaseUrl()}/l402/protected/${resourceId}`; const response = await fetch(url, { headers: { 'Authorization': lsatToken } }); if (response.ok) { const data = await response.json(); setStatus('request-status', 'Camera Switch accessed successfully!', 'success'); displayResource(data, lsatToken); } else if (response.status === 401 || response.status === 403 || response.status === 409) { console.warn(`Token access failed (${response.status}). Clearing stored token.`); const errorBody = await response.json(); const errorDetail = errorBody.detail || response.statusText; setStatus('request-status', `Access denied (${response.status}): ${errorDetail}. Token might be invalid/expired or resource in use.`, 'error'); clearToken(); window.currentToken = null; hideElement('resource-card'); } else { const errorText = await response.text(); throw new Error(`Server error ${response.status}: ${errorText}`); } } catch (error) { console.error("Error fetching Camera Switch with token:", error); setStatus('request-status', `Error accessing Camera Switch: ${error.message}`, 'error'); hideElement('resource-card'); }
        }

        function displayResource(data, lsatTokenUsed) {
            // ... (Implementation unchanged) ...
             const contentEl = document.getElementById('resource-content'); const tokenInfoEl = document.getElementById('token-info'); try { if (typeof data === 'object') { contentEl.textContent = JSON.stringify(data, null, 2); } else { contentEl.textContent = data; } } catch (e) { contentEl.textContent = String(data); } if (lsatTokenUsed && data.resource_id === CAMERA_SWITCH_RESOURCE_ID && data.access_expires) { window.currentToken = lsatTokenUsed; const expiresDate = new Date(data.access_expires * 1000).toLocaleString(); const tokenDisplay = lsatTokenUsed.length > 60 ? `${lsatTokenUsed.substring(0, 15)}...${lsatTokenUsed.substring(lsatTokenUsed.length - 40)}` : lsatTokenUsed; tokenInfoEl.textContent = `Token Used: ${tokenDisplay}\nResource: Camera Switch\nExpires: ${expiresDate}`; storeToken(lsatTokenUsed, data.access_expires); } else { tokenInfoEl.textContent = 'Camera Switch accessed (no LSAT token info available or needed).'; window.currentToken = null; } hideElement('invoice-card'); showElement('resource-card'); const reqStatusEl = document.getElementById('request-status'); if (reqStatusEl && !reqStatusEl.classList.contains('error')) { hideElement('request-status'); }
        }

        // --- Event Listeners ---
        document.addEventListener('DOMContentLoaded', () => {
            // Removed Tab Listeners

            // Main Request button
            document.getElementById('request-btn').addEventListener('click', requestCameraSwitchAccess);

            // Invoice Buttons
            document.getElementById('copy-invoice-btn').addEventListener('click', () => { /* ... unchanged ... */ const invoiceEl = document.getElementById('invoice'); navigator.clipboard.writeText(invoiceEl.value).then(() => { alert('Invoice copied to clipboard!'); }).catch(err => { console.error('Failed to copy invoice: ', err); alert('Failed to copy invoice.'); }); });

            // Manual Payment Check Button (Fallback)
            document.getElementById('check-payment-btn').addEventListener('click', () => {
                 const paymentHash = window.currentPaymentHash || document.getElementById('payment-hash').value;
                 if(paymentHash && !wsConnected) { // Only allow manual check if WS not connected
                     checkPaymentStatus(paymentHash);
                 } else if(wsConnected) {
                      alert("WebSocket is connected. Waiting for automatic confirmation.");
                 } else {
                      alert("No payment hash available to check.");
                 }
            });
            // Removed Auto-check Listener

            // Manual Preimage Button
             document.getElementById('use-preimage-btn').addEventListener('click', async () => {
                 const preimage = document.getElementById('preimage').value.trim();
                 const macaroon = window.currentMacaroon;
                 const resourceId = CAMERA_SWITCH_RESOURCE_ID;
                 if (!preimage || preimage.length !== 64 || !/^[0-9a-fA-F]+$/.test(preimage)) { alert('Please enter a valid 64-character hex preimage.'); return; }
                 if (!macaroon || !resourceId) { alert('Missing challenge information. Please request access first.'); return; }
                 setStatus('payment-status', 'Attempting access with manual preimage...', 'info');
                 const token = createLsatToken(macaroon, preimage);
                 if (token) {
                      disconnectWebSocket(); // Disconnect WS if using manual preimage
                      await fetchResourceWithToken(resourceId, token);
                 } else { alert('Failed to create token with provided details.'); }
             });

            // Resource Card Buttons
            document.getElementById('access-again-btn').addEventListener('click', async () => { /* ... unchanged ... */ const resourceId = CAMERA_SWITCH_RESOURCE_ID; const token = window.currentToken || getStoredToken(); if (token && resourceId) { await fetchResourceWithToken(resourceId, token); } else { alert('No valid token available. Please request access again.'); } });
            document.getElementById('clear-token-btn').addEventListener('click', () => { /* ... unchanged ... */ clearToken(); window.currentToken = null; alert(`Camera Switch token cleared.`); hideElement('resource-card'); setStatus('request-status', `Camera Switch token cleared.`, 'info'); disconnectWebSocket(); }); // Disconnect WS on clear

            // Removed Stored Tokens Clear Button listener

            // Initial setup
            requestCameraSwitchAccess(); // Auto-load the camera switch on page load
        });

        // Add cleanup on page unload
        window.addEventListener('beforeunload', () => {
             disconnectWebSocket();
        });
    </script>
</body>
</html>